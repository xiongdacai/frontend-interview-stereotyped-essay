# 浏览器安全
## XSS
1. 跨站脚本攻击：在网页中注入恶意脚本，使之在用户浏览器上运行，从而盗取用户信息。本质是浏览器未过滤恶意代码。
2. 可达到的目的：
   1. 获取页面数据。
   2. 占用服务器资源。
   3. 破坏页面结构，
   4. 流量劫持。
3. 类型：
   1. 存储型：脚本存储在服务器上，浏览器请求时传回。
   2. 反射型：诱导用户点击有恶意代码的URL，服务器将有恶意代码的数据发给浏览器，浏览器解析。
   3. DOM型：修改DOM形成XSS。
4. 防御：
   1. cookie使用http-only
   2. 针对vue的v-html或react的dangerouslySetInnerHTML，以及正常的innerHTML进行转义。
   3. content-secrurity-policy白名单
## CSRF
1. 跨站请求伪造：攻击者诱导用户进入第三方网站，该网站向被攻击网站发送跨站请求。如果该网站保存用户登录信息，那么攻击者就利用登录信息冒充用户操作。
2. 类型：
   1. GET型：img标签构建请求
   2. POST型：构建隐藏表单，在进入页面后提交
   3. 链接类型：a标签设置href
3. 防范：
   1. 同源检测
   2. token验证
   3. 设置cookie是设置samesite
## CORS
1. 同源策略：协议，域名，端口号相同。
2. 保证信息安全，限制js脚本。
3. 解决跨域：
   1. 后端放宽CORS限制
   2. JSONP：```<script src="http://requesturl.com?callback=handleCallback">```
   3. nginx代理服务器配置(TODO)
# 浏览器存储
## 强制缓存
1. 若浏览器判断所请求资源与所请求目标有效命中，则直接从强制缓存中返回，无需与服务器进行通信。
2. HTTP1.0协议引入expires，控制缓存失效时间戳。但有可能出现本地时间与服务器时钟不同步的现象造成失效。
3. HTTP1.1协议新增cache-control字段。
   1. no-cache:协商缓存。
   2. no-store：禁止使用任何缓存。
   3. public：同时能被浏览器和代理服务器缓存。
   4. private：只能被浏览器缓存。
   5. max-age：单位为秒，控制资源有效时长。
   6. s-maxage：代理服务器缓存有效时长。
## 协商缓存
1. 使用本地缓存前需发送get请求，与之协商浏览器本地缓存是否已过期。
2. Last-Modified：
   1. 第一次请求资源，服务器返回响应头包含last-modified和最后一次修改时间戳。cache-control为no-cache。
   2. 再次请求资源时携带if-modified-since字段，将该字段时间与目标资源时间戳对比，若没变化则返回304.
3. Etag：
   1. HTTP1.1引入Etag。根据文件资源内容进行哈希计算生成字符串。
   2. 服务端将该字符串与客户端请求头的if-None-Match携带是否一致。一致返回304，不一致返回Etag标头和Cache-Control：no-cache。
## 浏览器刷新
1. 点击刷新按钮或F5：
   1. 浏览器直接过期缓存文件
   2. 会在资源请求时携带if-Modified-Since,if-None-Match。故而返回结果可能为304。
2. Ctrl+F5强制刷新：
   1. 浏览器直接过期缓存文件
   2. 不会在资源请求时携带if-Modified-Since,if-None-Match。
3. 地址栏回车：
   1. 浏览器正常检查是否过期。
   2. 服务器检查新鲜度，返回内容。
## 本地存储
1. Cookie：
   1. 大小4kb，每次请求自动携带。
   2. 创建后无法修改，若删除只能修改过期时间为过去时间戳。
   3. 无法跨域。
   4. 包含字段：
      1. Value
      2. Size
      3. Name
      4. Path：可访问此cookie的页面路径
      5. Secure：是否用HTTPS安全协议发送cookie
      6. Domain：可访问该cookie的域名
      7. HTTP：包含http-only属性，控制能否通过脚本访问。
      8. Expires/max-size：过期时长
2. LocalStorage：
   1. 大小5MB。
   2. 持久存储，除非手动删除。
   3. 请求不会自动携带。
   4. IE8以下不兼容。
   5. 受同源策略限制。
   6. 风险：
      1. 明文存储。
      2. 会被广告追踪。
      3. 定期清除浏览器数据造成数据丢失。
3. SessionStorage：
   1. 类似于localStorage。
   2. 刷新时不会删除，但关闭窗口或标签页会。
4. IndexedDB：
   1. 键值对存储。任何类型都可直接存入。
   2. 异步，区别于localStorage。
   3. 不少于250MB的存储空间。
   4. 支持二进制存储。
## CDN
1. 内容分发网络(Content Delivery Network)。利用最靠近用户的服务器，更快，更可靠的将资源文件发送给用户。一般用于托管Web资源，用以加速访问。
2. 用途：
   1. 直播传送。
   2. 第三方CDN服务。
   3. 静态资源缓存。
## 代理服务器(TODO)

# 浏览器运转
## 渲染流程
1. 根据HTML生成DOM树
2. 根据CSS生成CSSOM规则树
3. 根据DOM树和CSSOM树构建渲染树。渲染树的节点被称为渲染对象，不可见的DOM元素不会插入渲染树。
4. 浏览器生成渲染树后，会根据渲染树进行布局。
5. 布局结束后调用渲染对象的paint方法进行绘制。
## 回流和重绘
1. 回流：
   1. 渲染树的部分或全部元素尺寸，结构，位置，内容发送变化时，浏览器会重新渲染。
      1. 首次渲染
      2. 浏览器窗口变化
      3. 元素内容变化
      4. 元素尺寸位置变化
      5. 元素字体大小变化
      6. 可见的DOM元素增删
2. 重绘：
   1. 元素样式发生变化，但不影响其在文档流位置，浏览器会进行重绘。
      1. color，background-color，background-image
      2. border-radius，visibility，box-shadow
3. 回流必然导致重绘，重绘未必引发回流。
## 从输入url到看到响应页面中间流程
1. DNS解析：通过url找到对应ip。
2. TCP链接：通过HTTP协议或HTTPS协议与服务器建立TCP连接。
3. HTTP请求：浏览器向服务器发送请求。
4. 响应处理：服务器收到请求进行处理，并给予响应。
5. 页面渲染：根据HTML文档生成DOM树和CSSOM树，并解析执行js代码。完成后渲染页面。
## 浏览器的三个核心线程
1. JS引擎线程：负责解析和执行JS代码。
2. GUI渲染线程：负责页面渲染，解析HTML，CSS构建DOM和CSSOM，进行布局和绘制。
3. 事件触进程：监听和处理事件。事件发生时会将事件放入消息队列，等待JS引擎处理。同时还负责处理定时延时器以及ajax处理。
## 事件机制
1. 事件类型：
   1. DOM0：直接在DOM对象注册事件名称。
   2. IE事件模型：两个过程：事件处理和事件冒泡。通过attachEvent添加监听函数。
   3. DOM2：三个过程：事件捕获，事件处理和事件冒泡。通过addEventListener绑定事件。
      1. 第三个参数若为布尔值(useCapture)则表示指定是否在捕获阶段执行
      2. 第三个参数若为对象，则：
         1. capture：等同于useCapture
         2. once：为true只会回调一次，调用后移出监听。
         3. passive：是否调用preventDefault。
2. 事件冒泡和事件捕获：
   1. 事件冒泡：事件触发的节点开始，事件上传到父节点。可借助该特性绑定父节点监听统一处理若干子节点，此方式为事件代理。阻止事件冒泡：```event.stopPropagation()```。
   2. 事件捕获：事件从document一直传播到目标元素。
3. 事件循环：
   1. js单线程运行，事件函数上下文会压入执行栈顺序执行。
   2. 任务队列分为宏任务队列和微任务队列，首次执行的代码可认为是宏任务队列代码。
   3. 遇到异步事件会先挂起根据类型放入宏任务队列或微任务队列，继续执行同步事件。
   4. 当首次宏任务队列任务执行完毕后检查微任务队列。执行微任务队列所有任务。
   5. 当执行完微任务后如有必要会渲染页面。
   6. 开始下一轮事件循环，运行宏任务队列代码。
4. 宏任务和微任务：
   1. 微任务：
      1. Promise的回调(Promise运行本身为同步代码)。
      2. node的process.nextTick()。
      3. 对DOM变化的监听。
   2. 宏任务：
      1. script脚本
      2. 定时器与延时器
      3. setImmediate
      4. I/O操作
      5. UI渲染
5. 执行栈：
   1. 存储函数调用的栈结构，先进后出。
   2. 栈存放函数有限制，递归不当会爆栈。
## 垃圾回收与内存泄漏
1. 引用计数：
   1. 标记跟踪对象被引用次数判断对象是否可回收。若为0则表示无引用，可回收。
   2. 无法处理循环引用，导致内存泄漏。
2. 标记清理：
   1. 从根对象开始，遍历内存可达对象打上标记，未被标记对象视为不可达。清除阶段将未被标记的对象进行清除。
3. 内存泄漏：
   1. 闭包。
   2. 全局变量。
      1. 未用var，let和const声明的变量。
   3. 事件绑定未解绑。
   4. 定时器未被清除。
   5. 循环引用。
